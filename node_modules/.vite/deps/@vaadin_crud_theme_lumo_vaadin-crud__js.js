import {
  FormLayout
} from "./chunk-K6XIEAYF.js";
import "./chunk-QVS5ZXWL.js";
import "./chunk-KRQV5XLI.js";
import "./chunk-EGRHWZRV.js";
import "./chunk-W4Z6XHHR.js";
import {
  Grid
} from "./chunk-7LJVNG5Q.js";
import "./chunk-WCPVLQ3S.js";
import "./chunk-WRZI7T35.js";
import "./chunk-4GMNRVMF.js";
import "./chunk-XDWGQIPP.js";
import "./chunk-6VGENHJ4.js";
import {
  Dialog,
  DialogOverlay
} from "./chunk-ONVO53L6.js";
import "./chunk-Y3OUJAZY.js";
import "./chunk-6AUVXKEV.js";
import {
  SlotMixin
} from "./chunk-7B2Z55OT.js";
import {
  MediaQueryController
} from "./chunk-WJZC25EU.js";
import "./chunk-EGRHWZRV.js";
import "./chunk-ZBVH3Q6O.js";
import "./chunk-KXLK7FPS.js";
import "./chunk-T7QYKO45.js";
import "./chunk-HGH6AG7S.js";
import "./chunk-CE2HX6X3.js";
import "./chunk-SKW7YDFR.js";
import "./chunk-DEWPIKLJ.js";
import "./chunk-O2SM2WC2.js";
import "./chunk-RVUVS4DM.js";
import "./chunk-QQHZ2G6C.js";
import "./chunk-67AQUJJH.js";
import "./chunk-5THRPDE7.js";
import "./chunk-3TE4RCOL.js";
import "./chunk-NEGQSXRC.js";
import "./chunk-26L5GZ27.js";
import "./chunk-AZPYW7JV.js";
import "./chunk-HWT6W2I7.js";
import "./chunk-DMBMGFGJ.js";
import "./chunk-37YVODLE.js";
import "./chunk-C2K2GOEG.js";
import "./chunk-7ZU5DFOG.js";
import "./chunk-2FVEPLVQ.js";
import "./chunk-7RDD4N5W.js";
import "./chunk-WE3EBNE7.js";
import "./chunk-XAUSENF3.js";
import {
  ControllerMixin
} from "./chunk-SG4ORNH2.js";
import {
  afterNextRender
} from "./chunk-UMTV3SEQ.js";
import {
  FlattenedNodesObserver
} from "./chunk-IZJSXIPS.js";
import "./chunk-W3OL3E37.js";
import "./chunk-ZB6KQ55W.js";
import "./chunk-PVLUQVE7.js";
import "./chunk-LUEFNUZH.js";
import "./chunk-IOVQFHDT.js";
import "./chunk-ZCT3SKJI.js";
import "./chunk-IFCXKWCQ.js";
import "./chunk-XKPFHVYZ.js";
import "./chunk-7OTQVW5F.js";
import {
  ElementMixin
} from "./chunk-4VEDPKK7.js";
import {
  Debouncer
} from "./chunk-VUWTYCVF.js";
import "./chunk-ZSBTYFKZ.js";
import {
  timeOut
} from "./chunk-CQH3N2QY.js";
import {
  PolymerElement,
  html
} from "./chunk-PE62AVRK.js";
import "./chunk-A5QYNKPK.js";
import "./chunk-NCN7ELFS.js";
import "./chunk-CJPRR7ZF.js";
import "./chunk-23T3EHLO.js";
import "./chunk-ETJWMQDB.js";
import "./chunk-NMW7U26J.js";
import "./chunk-DFW2W2Z7.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-STCAHPR7.js";
import {
  css
} from "./chunk-3DC23DJ2.js";
import "./chunk-ICHAVHAS.js";

// node_modules/@vaadin/crud/theme/lumo/vaadin-crud-styles.js
registerStyles(
  "vaadin-crud-edit",
  css`
    :host {
      min-width: auto;
      margin: 0;
      font-family: 'lumo-icons', var(--lumo-font-family);
      font-size: var(--lumo-icon-size-m);
      line-height: 1;
      position: relative;
      width: var(--lumo-size-s);
      height: var(--lumo-size-s);
      outline: none;
    }

    [part='icon']::before {
      content: var(--lumo-icons-edit);
      width: var(--lumo-size-m);
      height: var(--lumo-size-m);
      line-height: var(--lumo-size-m);
      text-align: center;
      position: absolute;
      top: calc((var(--lumo-size-m) - var(--lumo-size-s)) / -2);
      left: calc((var(--lumo-size-m) - var(--lumo-size-s)) / -2);
    }
  `,
  { moduleId: "lumo-crud-grid-edit" }
);
var editorStyles = css`
  [part='header'] ::slotted(h3) {
    margin-top: 0 !important;
  }

  :host(:not([dir='rtl'])) ::slotted([slot='delete-button']) {
    margin-right: auto;
  }

  :host([dir='rtl']) ::slotted([slot='delete-button']) {
    margin-left: auto;
  }
`;
registerStyles(
  "vaadin-crud",
  [
    editorStyles,
    css`
      :host {
        font-family: var(--lumo-font-family);
      }

      [part='scroller'] {
        padding: var(--lumo-space-l);
      }

      [part='toolbar'] {
        padding: var(--lumo-space-s) var(--lumo-space-m);
        background-color: var(--lumo-contrast-5pct);
        border: 1px solid var(--lumo-contrast-10pct);
        border-top: none;
      }

      :host(:not([dir='rtl'])) [part='toolbar'] ::slotted(*:not(:first-child)) {
        margin-left: var(--lumo-space-s);
      }

      :host([dir='rtl']) [part='toolbar'] ::slotted(*:not(:first-child)) {
        margin-right: var(--lumo-space-s);
      }

      :host([theme~='no-border']) [part='toolbar'] {
        border: 0;
      }

      [part='footer'] {
        background-color: var(--lumo-contrast-5pct);
        padding: var(--lumo-space-s);
      }

      [part='footer'] ::slotted(*) {
        margin-left: var(--lumo-space-s);
        margin-right: var(--lumo-space-s);
      }

      [part='editor'] {
        background: var(--lumo-base-color);
        box-sizing: border-box;
      }

      :host(:not([editor-position=''])) [part='editor']:not([hidden]) {
        box-shadow: var(--lumo-box-shadow-m);
      }

      :host(:not([theme~='no-border']):not([editor-position=''])) [part='editor']:not([hidden]) {
        border: 1px solid var(--lumo-contrast-20pct);
      }

      :host(:not([theme~='no-border'])[editor-position='bottom']) [part='editor']:not([hidden]) {
        border-top: 0;
      }

      :host(:not([dir='rtl'])[editor-position='aside']) [part='editor']:not([hidden]) {
        border-left: 0;
      }

      :host([dir='rtl']:not([theme~='no-border'])[editor-position='aside']) [part='editor']:not([hidden]) {
        border-right: 0;
      }
    `
  ],
  { moduleId: "lumo-crud" }
);
registerStyles(
  "vaadin-crud-dialog-overlay",
  [
    editorStyles,
    css`
      [part='header'] ::slotted(h3) {
        margin-top: 0 !important;
        margin-bottom: 0 !important;
        margin-inline-start: var(--lumo-space-s);
      }
    `
  ],
  {
    moduleId: "lumo-crud-dialog-overlay"
  }
);

// node_modules/@vaadin/crud/src/vaadin-crud-dialog.js
registerStyles(
  "vaadin-crud-dialog-overlay",
  css`
    [part='overlay'] {
      max-width: 54em;
      min-width: 20em;
    }

    [part='footer'] {
      justify-content: flex-start;
      flex-direction: row-reverse;
    }

    /* Make buttons clickable */
    [part='footer'] ::slotted(:not([disabled])) {
      pointer-events: all;
    }

    :host([fullscreen]) {
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 0;
    }

    :host([fullscreen]) [part='overlay'] {
      height: 100vh;
      width: 100vw;
      border-radius: 0 !important;
    }

    :host([fullscreen]) [part='content'] {
      flex: 1;
    }
  `,
  { moduleId: "vaadin-crud-dialog-overlay-styles" }
);
var memoizedTemplate;
var footerTemplate = html`
  <slot name="save-button"></slot>
  <slot name="cancel-button"></slot>
  <slot name="delete-button"></slot>
`;
var CrudDialogOverlay = class extends DialogOverlay {
  static get is() {
    return "vaadin-crud-dialog-overlay";
  }
  static get template() {
    if (!memoizedTemplate) {
      memoizedTemplate = super.template.cloneNode(true);
      const headerPart = memoizedTemplate.content.querySelector('[part="header"]');
      headerPart.innerHTML = "";
      const headerSlot = document.createElement("slot");
      headerSlot.setAttribute("name", "header");
      headerPart.appendChild(headerSlot);
      const contentPart = memoizedTemplate.content.querySelector('[part="content"]');
      const defaultSlot = contentPart.querySelector("slot:not([name])");
      defaultSlot.setAttribute("name", "form");
      const footerPart = memoizedTemplate.content.querySelector('[part="footer"]');
      footerPart.setAttribute("role", "toolbar");
      const footerSlot = footerPart.querySelector("slot");
      footerPart.removeChild(footerSlot);
      footerPart.appendChild(footerTemplate.content.cloneNode(true));
    }
    return memoizedTemplate;
  }
  _headerFooterRendererChange(headerRenderer, footerRenderer, opened) {
    super._headerFooterRendererChange(headerRenderer, footerRenderer, opened);
    this.setAttribute("has-header", "");
    this.setAttribute("has-footer", "");
  }
};
customElements.define("vaadin-crud-dialog-overlay", CrudDialogOverlay);
var CrudDialog = class extends Dialog {
  static get template() {
    return html`
      <style>
        :host {
          display: none;
        }
      </style>

      <vaadin-crud-dialog-overlay
        id="overlay"
        on-opened-changed="_onOverlayOpened"
        on-mousedown="_bringOverlayToFront"
        on-touchstart="_bringOverlayToFront"
        theme$="[[_theme]]"
        modeless="[[modeless]]"
        with-backdrop="[[!modeless]]"
        resizable$="[[resizable]]"
        focus-trap
      ></vaadin-crud-dialog-overlay>
    `;
  }
};
customElements.define("vaadin-crud-dialog", CrudDialog);

// node_modules/@vaadin/grid/src/vaadin-grid-filter.js
var GridFilter = class extends class extends PolymerElement {
} {
  static get template() {
    return html`
      <style>
        :host {
          display: inline-flex;
          max-width: 100%;
        }

        #filter {
          width: 100%;
          box-sizing: border-box;
        }
      </style>
      <slot name="filter">
        <vaadin-text-field id="filter" value="{{value}}"></vaadin-text-field>
      </slot>
    `;
  }
  static get is() {
    return "vaadin-grid-filter";
  }
  static get properties() {
    return {
      path: String,
      value: {
        type: String,
        notify: true
      },
      _connected: Boolean
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this._connected = true;
  }
  static get observers() {
    return ["_filterChanged(path, value, _connected)"];
  }
  ready() {
    super.ready();
    const child = this.firstElementChild;
    if (child && child.getAttribute("slot") !== "filter") {
      console.warn('Make sure you have assigned slot="filter" to the child elements of <vaadin-grid-filter>');
      child.setAttribute("slot", "filter");
    }
  }
  _filterChanged(path, value, connected) {
    if (path === void 0 || value === void 0 || !connected) {
      return;
    }
    if (this._previousValue === void 0 && value === "") {
      return;
    }
    this._previousValue = value;
    this._debouncerFilterChanged = Debouncer.debounce(this._debouncerFilterChanged, timeOut.after(200), () => {
      this.dispatchEvent(new CustomEvent("filter-changed", { bubbles: true }));
    });
  }
  focus() {
    this.$.filter.focus();
  }
};
customElements.define(GridFilter.is, GridFilter);

// node_modules/@vaadin/crud/src/vaadin-crud-include-mixin.js
var IncludedMixin = (superClass) => class IncludedMixin extends superClass {
  static get properties() {
    return {
      exclude: {
        value: "^_",
        observer: "__onExcludeChange"
      },
      include: {
        observer: "__onIncludeChange"
      }
    };
  }
  __onExcludeChange(exclude) {
    if (typeof exclude === "string") {
      this.exclude = exclude ? RegExp(exclude.replace(/, */g, "|"), "i") : void 0;
    }
  }
  __onIncludeChange(include) {
    if (typeof include === "string") {
      this.include = include ? include.split(/, */) : void 0;
    } else if (!this._fields && Array.isArray(include)) {
      const item = {};
      this.include.forEach((path) => this.__set(path, null, item));
      this._configure(item);
    }
  }
};

// node_modules/@vaadin/crud/src/vaadin-crud-grid.js
var CrudGrid = class extends IncludedMixin(Grid) {
  static get is() {
    return "vaadin-crud-grid";
  }
  static get properties() {
    return {
      noFilter: Boolean,
      noSort: Boolean,
      noHead: Boolean,
      __hideEditColumn: Boolean
    };
  }
  static get observers() {
    return ["__onItemsChange(items)", "__onHideEditColumnChange(hideEditColumn)"];
  }
  __onItemsChange(items) {
    if ((!this.dataProvider || this.dataProvider === this._arrayDataProvider) && !this.include && items && items[0]) {
      this._configure(items[0]);
    }
  }
  __onHideEditColumnChange() {
    if (this.firstChild) {
      this.__toggleEditColumn();
    }
  }
  __toggleEditColumn() {
    const el = this.querySelector("vaadin-crud-edit-column");
    if (this.hideEditColumn) {
      if (el) {
        this.removeChild(el);
      }
    } else if (!el) {
      this.appendChild(document.createElement("vaadin-crud-edit-column"));
    }
  }
  __dataProviderWrapper(params, callback) {
    this.__dataProvider(params, (items, size) => {
      if (this.innerHTML === "" && !this.include && items[0]) {
        this._configure(items[0]);
      }
      callback(items, size);
    });
  }
  _dataProviderChanged(dataProvider, oldDataProvider) {
    if (this._arrayDataProvider === dataProvider) {
      super._dataProviderChanged(dataProvider, oldDataProvider);
    } else if (this.__dataProviderWrapper !== dataProvider) {
      this.innerHTML = "";
      this.__dataProvider = dataProvider;
      this.dataProvider = this.__dataProviderWrapper;
      super._dataProviderChanged(this.__dataProviderWrapper, oldDataProvider);
    }
  }
  _configure(item) {
    this.innerHTML = "";
    this.__createColumns(this, item, void 0, this.__getPropertyDepth(item));
    this.__toggleEditColumn();
  }
  __getPropertyDepth(object) {
    if (!object || typeof object !== "object") {
      return 0;
    }
    return Object.keys(object).reduce((deepest, prop) => {
      if (this.exclude && this.exclude.test(prop)) {
        return deepest;
      }
      return Math.max(deepest, 1 + this.__getPropertyDepth(object[prop]));
    }, 0);
  }
  _generateHeader(path) {
    return path.substr(path.lastIndexOf(".") + 1).replace(/([A-Z])/g, "-$1").toLowerCase().replace(/-/g, " ").replace(/^./, (match) => match.toUpperCase());
  }
  __createColumn(parent, path) {
    let col;
    if (!this.noFilter && !this.noSort && !parent.__sortColumnGroup) {
      col = this.__createGroup(parent);
      col.__sortColumnGroup = true;
      this.__createColumn(col, path);
    } else {
      col = document.createElement("vaadin-grid-column");
      parent.appendChild(col);
      col.renderer = (root, _column, model) => {
        root.textContent = path ? this.get(path, model.item) : model.item;
      };
    }
    if (!this.noHead && path) {
      col.headerRenderer = (root) => {
        if (root.firstElementChild) {
          return;
        }
        const label = this._generateHeader(path);
        if (col.__sortColumnGroup || this.noFilter && !this.noSort) {
          const sorter = document.createElement("vaadin-grid-sorter");
          sorter.setAttribute("path", path);
          sorter.setAttribute("aria-label", `Sort by ${label}`);
          sorter.textContent = label;
          root.appendChild(sorter);
        } else if (!this.noFilter) {
          const filter = document.createElement("vaadin-grid-filter");
          filter.setAttribute("path", path);
          filter.setAttribute("aria-label", `Filter by ${label}`);
          filter.style.display = "flex";
          const textField = window.document.createElement("vaadin-text-field");
          textField.setAttribute("theme", "small");
          textField.setAttribute("slot", "filter");
          textField.setAttribute("focus-target", true);
          textField.style.width = "100%";
          if (this.noSort) {
            textField.placeholder = label;
          }
          textField.addEventListener("value-changed", (event) => {
            filter.value = event.detail.value;
          });
          filter.appendChild(textField);
          root.appendChild(filter);
        } else if (this.noSort && this.noFilter) {
          root.textContent = label;
        }
      };
    }
  }
  __createColumns(parent, object, path, depth) {
    if (object && typeof object === "object") {
      Object.keys(object).forEach((prop) => {
        if (!this.include && this.exclude && this.exclude.test(prop)) {
          return;
        }
        const subObject = object[prop];
        const subObjectPath = path ? `${path}.${prop}` : prop;
        let subObjectColumn = parent;
        if (!this.noHead && depth > 1) {
          const isSubObject = subObject && typeof subObject === "object";
          subObjectColumn = this.__createGroup(parent, isSubObject ? prop : void 0);
        }
        this.__createColumns(subObjectColumn, subObject, subObjectPath, depth - 1);
      });
    } else if (depth > 1) {
      this.__createColumns(this.__createGroup(parent), void 0, path, depth - 1);
    } else {
      this.__createColumn(parent, path);
    }
  }
  __createGroup(parent, header) {
    const grp = document.createElement("vaadin-grid-column-group");
    if (header) {
      grp.header = this.__capitalize(header);
    }
    parent.appendChild(grp);
    return grp;
  }
  __capitalize(path) {
    return path.toLowerCase().replace(/([^\w]+)/g, " ").trim().replace(/^./, (c) => c.toUpperCase());
  }
  __set(path, val, obj) {
    if (obj && path) {
      path.split(".").slice(0, -1).reduce((o, p) => {
        o[p] = o[p] || {};
        return o[p];
      }, obj);
      this.set(path, val, obj);
    }
  }
};
customElements.define(CrudGrid.is, CrudGrid);

// node_modules/@vaadin/crud/src/vaadin-crud-form.js
var CrudForm = class extends IncludedMixin(FormLayout) {
  static get is() {
    return "vaadin-crud-form";
  }
  static get properties() {
    return {
      item: Object
    };
  }
  static get observers() {
    return ["__onItemChange(item)"];
  }
  _configure(object) {
    this.innerHTML = "";
    this._fields = [];
    this.__createFields(this, object);
    this._updateLayout();
  }
  __onItemChange(item) {
    if (!this._fields) {
      this._configure(item);
    }
  }
  __createField(parent, path) {
    const field = document.createElement("vaadin-text-field");
    field.label = this.__capitalize(path);
    field.path = path;
    field.required = true;
    parent.appendChild(field);
    this._fields.push(field);
    return field;
  }
  __createFields(parent, object, path) {
    Object.keys(object).forEach((prop) => {
      if (!this.include && this.exclude && this.exclude.test(prop)) {
        return;
      }
      const newPath = (path ? `${path}.` : "") + prop;
      if (object[prop] && typeof object[prop] === "object") {
        this.__createFields(parent, object[prop], newPath);
      } else {
        this.__createField(parent, newPath);
      }
    });
    if (!this._fields.length) {
      this._fields = void 0;
    }
  }
  __capitalize(path) {
    return path.toLowerCase().replace(/([^\w]+)/g, " ").trim().replace(/^./, (c) => c.toUpperCase());
  }
  __set(path, val, obj) {
    if (obj && path) {
      path.split(".").slice(0, -1).reduce((o, p) => {
        o[p] = o[p] || {};
        return o[p];
      }, obj);
      this.set(path, val, obj);
    }
  }
};
customElements.define(CrudForm.is, CrudForm);

// node_modules/@vaadin/crud/src/vaadin-crud.js
var Crud = class extends SlotMixin(ControllerMixin(ElementMixin(ThemableMixin(PolymerElement)))) {
  static get template() {
    return html`
      <style>
        :host {
          width: 100%;
          height: 400px;
          --vaadin-crud-editor-max-height: 40%;
          --vaadin-crud-editor-max-width: 40%;
        }

        :host,
        #main {
          display: flex;
          flex-direction: column;
          align-self: stretch;
          position: relative;
          overflow: hidden;
        }

        #main {
          flex: 1 1 100%;
          height: 100%;
        }

        :host([hidden]),
        [hidden] {
          display: none !important;
        }

        [part='toolbar'] {
          display: flex;
          flex-shrink: 0;
          align-items: baseline;
          justify-content: flex-end;
        }

        :host([no-toolbar]) [part='toolbar'] {
          display: none;
        }

        #container {
          display: flex;
          height: 100%;
        }

        :host([editor-position='bottom']) #container {
          flex-direction: column;
        }

        [part='editor'] {
          z-index: 1;
          display: flex;
          flex-direction: column;
          height: 100%;
        }

        :host(:not([editor-position=''])[editor-opened]:not([fullscreen])) [part='editor'] {
          flex: 1 0 100%;
        }

        :host([editor-position='bottom'][editor-opened]:not([fullscreen])) [part='editor'] {
          max-height: var(--vaadin-crud-editor-max-height);
        }

        :host([editor-position='aside'][editor-opened]:not([fullscreen])) [part='editor'] {
          min-width: 300px;
          max-width: var(--vaadin-crud-editor-max-width);
        }

        [part='scroller'] {
          display: flex;
          flex-direction: column;
          overflow: auto;
          flex: auto;
        }

        [part='footer'] {
          display: flex;
          flex: none;
          flex-direction: row-reverse;
        }
      </style>

      <div id="container">
        <div id="main">
          <slot name="grid">
            <vaadin-crud-grid
              theme$="[[_theme]]"
              id="grid"
              include="[[include]]"
              exclude="[[exclude]]"
              no-sort="[[noSort]]"
              no-filter="[[noFilter]]"
              no-head="[[noHead]]"
              hide-edit-column="[[editOnClick]]"
            ></vaadin-crud-grid>
          </slot>

          <div id="toolbar" part="toolbar" on-click="__new">
            <slot name="toolbar">
              <vaadin-button new-button="" id="new" theme="primary">[[i18n.newItem]]</vaadin-button>
            </slot>
          </div>
        </div>

        <div id="editor" part="editor" hidden$="[[__computeEditorHidden(editorOpened, _fullscreen, editorPosition)]]">
          <div part="scroller" id="scroller" role="group" aria-labelledby="header">
            <div part="header" id="header">
              <slot name="header"></slot>
            </div>
            <slot name="form"></slot>
          </div>

          <div part="footer" role="toolbar">
            <slot name="save-button"></slot>
            <slot name="cancel-button"></slot>
            <slot name="delete-button"></slot>
          </div>
        </div>
      </div>

      <vaadin-crud-dialog
        id="dialog"
        opened="[[__computeDialogOpened(editorOpened, _fullscreen, editorPosition)]]"
        aria-label="[[__editorAriaLabel]]"
        no-close-on-outside-click="[[__isDirty]]"
        no-close-on-esc="[[__isDirty]]"
        theme$="[[_theme]]"
        on-opened-changed="__onDialogOpened"
      ></vaadin-crud-dialog>

      <vaadin-confirm-dialog
        theme$="[[_theme]]"
        id="confirmCancel"
        on-confirm="__confirmCancel"
        cancel
        confirm-text="[[i18n.confirm.cancel.button.confirm]]"
        cancel-text="[[i18n.confirm.cancel.button.dismiss]]"
        header="[[i18n.confirm.cancel.title]]"
        message="[[i18n.confirm.cancel.content]]"
        confirm-theme="primary"
      ></vaadin-confirm-dialog>

      <vaadin-confirm-dialog
        theme$="[[_theme]]"
        id="confirmDelete"
        on-confirm="__confirmDelete"
        cancel
        confirm-text="[[i18n.confirm.delete.button.confirm]]"
        cancel-text="[[i18n.confirm.delete.button.dismiss]]"
        header="[[i18n.confirm.delete.title]]"
        message="[[i18n.confirm.delete.content]]"
        confirm-theme="primary error"
      ></vaadin-confirm-dialog>
    `;
  }
  static get is() {
    return "vaadin-crud";
  }
  static get cvdlName() {
    return "vaadin-crud";
  }
  static get properties() {
    return {
      _grid: {
        type: HTMLElement,
        observer: "__gridChanged"
      },
      _form: {
        type: HTMLElement,
        observer: "__formChanged"
      },
      _saveButton: {
        type: HTMLElement,
        observer: "__saveButtonChanged"
      },
      _deleteButton: {
        type: HTMLElement,
        observer: "__deleteButtonChanged"
      },
      _cancelButton: {
        type: HTMLElement,
        observer: "__cancelButtonChanged"
      },
      _headerNode: {
        type: HTMLElement
      },
      items: {
        type: Array,
        notify: true,
        observer: "__itemsChanged"
      },
      editedItem: {
        type: Object,
        observer: "__editedItemChanged",
        notify: true
      },
      editorPosition: {
        type: String,
        value: "",
        reflectToAttribute: true,
        observer: "__editorPositionChanged"
      },
      editOnClick: {
        type: Boolean,
        value: false
      },
      dataProvider: {
        type: Function,
        observer: "__dataProviderChanged"
      },
      noFilter: Boolean,
      noSort: Boolean,
      noHead: Boolean,
      include: String,
      exclude: String,
      editorOpened: {
        type: Boolean,
        reflectToAttribute: true,
        notify: true,
        observer: "__editorOpenedChanged"
      },
      size: {
        type: Number,
        readOnly: true,
        notify: true
      },
      noToolbar: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      i18n: {
        type: Object,
        value() {
          return {
            newItem: "New item",
            editItem: "Edit item",
            saveItem: "Save",
            cancel: "Cancel",
            deleteItem: "Delete...",
            editLabel: "Edit",
            confirm: {
              delete: {
                title: "Delete item",
                content: "Are you sure you want to delete this item? This action cannot be undone.",
                button: {
                  confirm: "Delete",
                  dismiss: "Cancel"
                }
              },
              cancel: {
                title: "Discard changes",
                content: "There are unsaved changes to this item.",
                button: {
                  confirm: "Discard",
                  dismiss: "Cancel"
                }
              }
            }
          };
        }
      },
      __editorAriaLabel: String,
      __isDirty: Boolean,
      __isNew: Boolean,
      _fullscreen: {
        type: Boolean,
        observer: "__fullscreenChanged"
      },
      _fullscreenMediaQuery: {
        value: "(max-width: 600px), (max-height: 600px)"
      }
    };
  }
  static get observers() {
    return [
      "__headerPropsChanged(_headerNode, __isNew, i18n.newItem, i18n.editItem)",
      "__formPropsChanged(_form, _theme, include, exclude)",
      "__i18nChanged(i18n, _grid)",
      "__editOnClickChanged(editOnClick, _grid)",
      "__saveButtonPropsChanged(_saveButton, i18n.saveItem, __isDirty)",
      "__cancelButtonPropsChanged(_cancelButton, i18n.cancel)",
      "__deleteButtonPropsChanged(_deleteButton, i18n.deleteItem, __isNew)"
    ];
  }
  static _isValidEditorPosition(editorPosition) {
    return ["bottom", "aside"].includes(editorPosition);
  }
  get slots() {
    return {
      ...super.slots,
      header: () => {
        return document.createElement("h3");
      },
      form: () => {
        return document.createElement("vaadin-crud-form");
      },
      "save-button": () => {
        const button = document.createElement("vaadin-button");
        button.id = "save";
        button.setAttribute("theme", "primary");
        return button;
      },
      "cancel-button": () => {
        const button = document.createElement("vaadin-button");
        button.id = "cancel";
        button.setAttribute("theme", "tertiary");
        return button;
      },
      "delete-button": () => {
        const button = document.createElement("vaadin-button");
        button.id = "delete";
        button.setAttribute("theme", "tertiary error");
        return button;
      }
    };
  }
  constructor() {
    super();
    this._observer = new FlattenedNodesObserver(this, (info) => {
      this.__onDomChange(info.addedNodes);
    });
  }
  ready() {
    super.ready();
    this.__save = this.__save.bind(this);
    this.__cancel = this.__cancel.bind(this);
    this.__delete = this.__delete.bind(this);
    this.__onFormChange = this.__onFormChange.bind(this);
    this.__onGridEdit = this.__onGridEdit.bind(this);
    this.__onGridSizeChanged = this.__onGridSizeChanged.bind(this);
    this.__onGridActiveItemChanged = this.__onGridActiveItemChanged.bind(this);
    this._grid = this.$.grid;
    this.$.dialog.$.overlay.addEventListener("vaadin-overlay-outside-click", this.__cancel);
    this.$.dialog.$.overlay.addEventListener("vaadin-overlay-escape-press", this.__cancel);
    this.addController(
      new MediaQueryController(this._fullscreenMediaQuery, (matches) => {
        this._fullscreen = matches;
      })
    );
  }
  __isSaveBtnDisabled(isDirty) {
    return !isDirty;
  }
  __headerPropsChanged(headerNode, isNew, i18nNewItem, i18nEditItem) {
    if (headerNode) {
      headerNode.textContent = isNew ? i18nNewItem : i18nEditItem;
    }
  }
  __i18nChanged(i18n, grid) {
    if (!grid) {
      return;
    }
    afterNextRender(grid, () => {
      Array.from(grid.querySelectorAll("vaadin-crud-edit-column")).forEach((column) => {
        column.ariaLabel = i18n.editLabel;
      });
    });
  }
  __editorPositionChanged(editorPosition) {
    if (Crud._isValidEditorPosition(editorPosition)) {
      return;
    }
    this.editorPosition = "";
  }
  __editorOpenedChanged(opened, oldOpened) {
    if (!opened && oldOpened) {
      this.__closeEditor();
    } else {
      this.__formChanged(this._form);
    }
    if (opened) {
      this.__ensureChildren();
    }
    this.__toggleToolbar();
    this.$.scroller.scrollTop = 0;
  }
  __fullscreenChanged(fullscreen, oldFullscreen) {
    if (fullscreen || oldFullscreen) {
      this.__toggleToolbar();
      this.__ensureChildren();
      this.toggleAttribute("fullscreen", fullscreen);
      this.$.dialog.$.overlay.toggleAttribute("fullscreen", fullscreen);
    }
  }
  __toggleToolbar() {
    if (this.editorPosition === "bottom" && !this._fullscreen) {
      this.$.toolbar.style.display = this.editorOpened ? "none" : "";
    }
  }
  __moveChildNodes(target) {
    const nodes = [this._headerNode, this._form, this._saveButton, this._cancelButton, this._deleteButton];
    if (!nodes.every((node) => node instanceof HTMLElement)) {
      return;
    }
    nodes.forEach((node) => {
      target.appendChild(node);
    });
    setTimeout(() => {
      this.__dialogAriaLabel = this._headerNode.textContent.trim();
    });
  }
  __shouldOpenDialog(fullscreen, editorPosition) {
    return editorPosition === "" || fullscreen;
  }
  __ensureChildren() {
    if (this.__shouldOpenDialog(this._fullscreen, this.editorPosition)) {
      this.__moveChildNodes(this.$.dialog.$.overlay);
    } else {
      this.__moveChildNodes(this);
    }
  }
  __computeDialogOpened(opened, fullscreen, editorPosition) {
    return this.__shouldOpenDialog(fullscreen, editorPosition) ? opened : false;
  }
  __computeEditorHidden(opened, fullscreen, editorPosition) {
    if (["aside", "bottom"].includes(editorPosition) && !fullscreen) {
      return !opened;
    }
    return true;
  }
  __onDialogOpened(event) {
    this.editorOpened = event.detail.value;
  }
  __onDomChange(addedNodes) {
    addedNodes.filter((node) => node.nodeType === Node.ELEMENT_NODE).forEach((node) => {
      const slotAttributeValue = node.getAttribute("slot");
      if (!slotAttributeValue) {
        return;
      }
      if (slotAttributeValue === "grid") {
        this.__editOnClickChanged(false, this._grid);
        this._grid = node;
        this.__editOnClickChanged(this.editOnClick, this._grid);
      } else if (slotAttributeValue === "form") {
        this._form = node;
      } else if (slotAttributeValue.indexOf("button") >= 0) {
        const [button] = slotAttributeValue.split("-");
        this[`_${button}Button`] = node;
      } else if (slotAttributeValue === "header") {
        this._headerNode = node;
      }
    });
    if (this.editorOpened) {
      this.__ensureChildren();
    }
  }
  __onGridEdit(event) {
    event.stopPropagation();
    this.__confirmBeforeChangingEditedItem(event.detail.item);
  }
  __onFormChange() {
    this.__isDirty = true;
  }
  __onGridSizeChanged() {
    this._setSize(this._grid.size);
  }
  __gridChanged(grid, oldGrid) {
    if (oldGrid) {
      oldGrid.removeEventListener("edit", this.__onGridEdit);
      oldGrid.removeEventListener("size-changed", this.__onGridSizeChanged);
    }
    if (this.dataProvider) {
      this.__dataProviderChanged(this.dataProvider);
    }
    if (this.items) {
      this.__itemsChanged(this.items);
    }
    if (this.editedItem) {
      this.__editedItemChanged(this.editedItem);
    }
    grid.addEventListener("edit", this.__onGridEdit);
    grid.addEventListener("size-changed", this.__onGridSizeChanged);
    this.__onGridSizeChanged();
  }
  __formChanged(form, oldForm) {
    if (oldForm && oldForm.parentElement) {
      oldForm.parentElement.removeChild(oldForm);
      oldForm.removeEventListener("change", this.__onFormChange);
      oldForm.removeEventListener("input", this.__onFormChange);
    }
    if (!form) {
      return;
    }
    if (this.items) {
      this.__itemsChanged(this.items);
    }
    if (this.editedItem) {
      this.__editedItemChanged(this.editedItem);
    }
    form.addEventListener("change", this.__onFormChange);
    form.addEventListener("input", this.__onFormChange);
  }
  __formPropsChanged(form, theme, include, exclude) {
    if (form) {
      form.include = include;
      form.exclude = exclude;
      if (theme) {
        form.setAttribute("theme", theme);
      } else {
        form.removeAttribute("theme");
      }
    }
  }
  __saveButtonChanged(saveButton, oldSaveButton) {
    this.__setupSlottedButton(saveButton, oldSaveButton, this.__save);
  }
  __saveButtonPropsChanged(saveButton, i18nLabel, isDirty) {
    if (saveButton) {
      saveButton.toggleAttribute("disabled", this.__isSaveBtnDisabled(isDirty));
      saveButton.textContent = i18nLabel;
    }
  }
  __deleteButtonChanged(deleteButton, oldDeleteButton) {
    this.__setupSlottedButton(deleteButton, oldDeleteButton, this.__delete);
  }
  __deleteButtonPropsChanged(deleteButton, i18nLabel, isNew) {
    if (deleteButton) {
      deleteButton.textContent = i18nLabel;
      deleteButton.toggleAttribute("hidden", isNew);
    }
  }
  __cancelButtonChanged(cancelButton, oldCancelButton) {
    this.__setupSlottedButton(cancelButton, oldCancelButton, this.__cancel);
  }
  __cancelButtonPropsChanged(cancelButton, i18nLabel) {
    if (cancelButton) {
      cancelButton.textContent = i18nLabel;
    }
  }
  __setupSlottedButton(newButton, oldButton, clickListener) {
    if (oldButton && oldButton.parentElement) {
      oldButton.parentElement.removeChild(oldButton);
    }
    newButton.addEventListener("click", clickListener);
  }
  __dataProviderChanged(dataProvider) {
    if (this._grid) {
      this._grid.dataProvider = this.__createDataProviderProxy(dataProvider);
    }
  }
  __editOnClickChanged(editOnClick, _grid) {
    if (!_grid) {
      return;
    }
    if (editOnClick) {
      _grid.addEventListener("active-item-changed", this.__onGridActiveItemChanged);
    } else {
      _grid.removeEventListener("active-item-changed", this.__onGridActiveItemChanged);
    }
  }
  __onGridActiveItemChanged(event) {
    const item = event.detail.value;
    if (this.editorOpened && this.__isDirty) {
      this.__confirmBeforeChangingEditedItem(item);
      return;
    }
    if (item) {
      this.__edit(item);
    } else if (!this.__keepOpened) {
      this.__closeEditor();
    }
  }
  __confirmBeforeChangingEditedItem(item, keepOpened) {
    if (this.editorOpened && this.__isDirty && this.editedItem !== item) {
      this.$.confirmCancel.opened = true;
      const listenOnce = (event) => {
        event.preventDefault();
        if (item || keepOpened) {
          this.__edit(item);
          this.__clearItemAndKeepEditorOpened(item, keepOpened);
        } else {
          this.__closeEditor();
        }
        this.removeEventListener("cancel", listenOnce);
      };
      this.addEventListener("cancel", listenOnce);
    } else {
      this.__edit(item);
      this.__clearItemAndKeepEditorOpened(item, keepOpened);
    }
  }
  __clearItemAndKeepEditorOpened(item, keepOpened) {
    if (!item) {
      setTimeout(() => {
        this.__keepOpened = keepOpened;
        this.editedItem = this._grid.activeItem = void 0;
      });
    }
  }
  __createDataProviderProxy(dataProvider) {
    return (params, callback) => {
      const callbackProxy = (chunk, size) => {
        if (chunk && chunk[0]) {
          this.__model = chunk[0];
        }
        callback(chunk, size);
      };
      dataProvider(params, callbackProxy);
    };
  }
  __itemsChanged(items) {
    if (this.items && this.items[0]) {
      this.__model = items[0];
    }
    if (this._grid) {
      this._grid.items = items;
    }
  }
  __editedItemChanged(item) {
    if (!this._form) {
      return;
    }
    if (item) {
      if (!this._fields.length && this._form._configure) {
        if (this.__model) {
          this._form._configure(this.__model);
        } else {
          console.warn(
            "<vaadin-crud> Unable to autoconfigure form because the data structure is unknown. Either specify `include` or ensure at least one item is available beforehand."
          );
        }
      }
      this._form.item = item;
      this._fields.forEach((e) => {
        const path = e.path || e.getAttribute("path");
        if (path) {
          e.value = this.get(path, item);
        }
      });
      this.__isNew = !!(this.__isNew || this.items && this.items.indexOf(item) < 0);
      this.editorOpened = true;
    }
  }
  get _fields() {
    if (!this.__fields || !this.__fields.length) {
      this.__fields = Array.from(this._form.querySelectorAll("*")).filter((e) => e.validate || e.checkValidity);
    }
    return this.__fields;
  }
  __validate() {
    return this._fields.every((e) => (e.validate || e.checkValidity).call(e));
  }
  __setHighlightedItem(item) {
    if (this._grid === this.$.grid) {
      this._grid.selectedItems = item ? [item] : [];
    }
  }
  __closeEditor() {
    this.editorOpened = false;
    this.__isDirty = false;
    this.__setHighlightedItem(null);
    setTimeout(() => this.__clearItemAndKeepEditorOpened(null, false));
  }
  __new(event) {
    if (event.composedPath().filter((e) => e.nodeType === 1 && e.hasAttribute("new-button"))[0]) {
      this.__confirmBeforeChangingEditedItem(null, true);
    }
  }
  __edit(item) {
    if (this.editedItem === item) {
      return;
    }
    this.__setHighlightedItem(item);
    this.__openEditor("edit", item);
  }
  __openEditor(type, item) {
    this.__isDirty = false;
    this.__isNew = !item;
    const evt = this.dispatchEvent(
      new CustomEvent(this.__isNew ? "new" : "edit", { detail: { item }, cancelable: true })
    );
    if (evt) {
      this.editedItem = item || {};
    } else {
      this.editorOpened = true;
    }
  }
  __save() {
    if (!this.__validate()) {
      return;
    }
    const item = { ...this.editedItem };
    this._fields.forEach((e) => {
      const path = e.path || e.getAttribute("path");
      if (path) {
        this.__set(path, e.value, item);
      }
    });
    const evt = this.dispatchEvent(new CustomEvent("save", { detail: { item }, cancelable: true }));
    if (evt) {
      if (this.__isNew && !this.dataProvider) {
        if (!this.items) {
          this.items = [item];
        } else {
          this.items.push(item);
        }
      } else {
        this.editedItem = this.editedItem || {};
        Object.assign(this.editedItem, item);
      }
      this._grid.clearCache();
      this.__closeEditor();
    }
  }
  __cancel() {
    if (this.__isDirty) {
      this.$.confirmCancel.opened = true;
    } else {
      this.__confirmCancel();
    }
  }
  __confirmCancel() {
    const evt = this.dispatchEvent(new CustomEvent("cancel", { detail: { item: this.editedItem }, cancelable: true }));
    if (evt) {
      this.__closeEditor();
    }
  }
  __delete() {
    this.$.confirmDelete.opened = true;
  }
  __confirmDelete() {
    const evt = this.dispatchEvent(new CustomEvent("delete", { detail: { item: this.editedItem }, cancelable: true }));
    if (evt) {
      if (this.items && this.items.indexOf(this.editedItem) >= 0) {
        this.items.splice(this.items.indexOf(this.editedItem), 1);
      }
      this._grid.clearCache();
      this.__closeEditor();
    }
  }
  __set(path, val, obj) {
    if (obj && path) {
      path.split(".").slice(0, -1).reduce((o, p) => {
        o[p] = o[p] || {};
        return o[p];
      }, obj);
      this.set(path, val, obj);
    }
  }
};
customElements.define(Crud.is, Crud);
/**
 * @license
 * Copyright (c) 2016 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
/**
 * @license
 * Copyright (c) 2018 - 2022 Vaadin Ltd.
 * This program is available under Commercial Vaadin Developer License 4.0, available at https://vaadin.com/license/cvdl-4.0.
 */
//# sourceMappingURL=@vaadin_crud_theme_lumo_vaadin-crud__js.js.map
